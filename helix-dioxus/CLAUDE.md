# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Workspace Context

helix-dioxus is a crate inside the [helix](https://github.com/helix-editor/helix) monorepo workspace. It depends on sibling crates (`helix-core`, `helix-view`, `helix-lsp`, `helix-event`, `helix-loader`, `helix-vcs`, `helix-stdx`) via relative path dependencies. The parent workspace root is at `../`.

## Architecture

helix-dioxus is a Dioxus 0.7 desktop frontend for the Helix text editor, structured as a library crate with a `dhx` binary.

### Key Architectural Pattern

- **Message Passing**: EditorContext (non-Send/Sync) lives on main thread
- **Commands**: UI sends EditorCommand via mpsc channel
- **Snapshots**: EditorSnapshot captures state for rendering (Clone + Send + Sync)
- **Thread-local**: EDITOR_CTX provides synchronous access for immediate updates

### Module Structure

```
helix-dioxus/src/
├── lib.rs                      # Library root: launch(), AppState, public module declarations
├── config.rs                   # DhxConfig: window, font, logging settings (from dhx.toml)
├── app.rs                      # Root App component
├── events.rs                   # Event registration for helix_event (MUST run before hooks)
├── hooks.rs                    # Custom Dioxus hooks (use_editor_snapshot)
├── test_helpers.rs             # Test utilities (init(), test setup)
├── integration_tests.rs        # Integration tests (dot-repeat, etc.)
│
├── icons/                      # Icon data (generated by dioxus-iconify CLI)
│   ├── mod.rs                  # Icon component + IconData struct
│   ├── lucide.rs               # 37 Lucide UI icon constants (stroke-based)
│   ├── logos.rs                 # 1 logo icon (Go)
│   └── vscode_icons.rs         # 37 VSCode file type icon constants (colorful SVGs)
│
├── main.rs                     # Binary entry point: loads config, inits tracing/loader, launches app
├── args.rs                     # Command-line argument parsing → StartupAction
├── tracing_setup.rs            # Tracing subscriber init from LoggingConfig
│
├── lsp/                        # LSP Data & Logic
│   ├── mod.rs                  # Re-exports types and conversions
│   ├── types.rs                # LSP snapshot types (CodeActionSnapshot, CompletionItem, etc.)
│   ├── conversions.rs          # helix-lsp → snapshot type conversions
│   └── diff.rs                 # Diff computation for code action preview
│
├── components/                 # UI Components
│   ├── mod.rs                  # Re-exports all components
│   ├── editor_view.rs          # Document rendering with syntax highlighting
│   ├── buffer_bar.rs           # Tab bar with scroll buttons (uses PopupMenu for context menu)
│   ├── kbd.rs                  # Reusable KbdKey component (physical key styling)
│   ├── modal_overlay.rs        # Reusable ModalOverlay (overlay+backdrop+container)
│   ├── popup_menu.rs           # Reusable PopupMenu (positioned context menu with backdrop)
│   ├── statusline.rs           # Mode, filename, position display
│   ├── keybinding_help.rs      # Context-aware keybinding help bar
│   ├── scrollbar.rs            # Custom scrollbar with diagnostic markers
│   ├── diagnostics.rs          # Diagnostic rendering helpers
│   ├── git_diff_popup.rs       # Git diff hover popup (revert/copy actions)
│   ├── file_icons/             # File/folder type icons (via dioxus-iconify)
│   │   └── mod.rs              # FileTypeIcon, FolderTypeIcon components + filename→IconData mapping
│   ├── lsp/                    # LSP-related popups
│   │   ├── mod.rs              # Re-exports
│   │   ├── code_actions.rs     # Code actions menu (two-column with preview)
│   │   ├── code_action_preview.rs # Diff preview panel for code actions
│   │   ├── completion.rs       # Completion popup (uses InlineListDialog)
│   │   ├── hover.rs            # Hover popup (uses InlineDialogContainer)
│   │   ├── signature_help.rs   # Signature help (uses InlineDialogContainer)
│   │   ├── location_picker.rs  # Location picker for LSP references/definitions
│   │   └── markdown.rs         # Markdown parsing and rendering for LSP popups
│   ├── dialog/                 # Dialogs and prompts
│   │   ├── mod.rs              # Re-exports
│   │   ├── command_completion.rs # Command completion popup (fuzzy-filtered above : prompt)
│   │   ├── confirmation.rs     # Confirmation dialog (quit with unsaved changes)
│   │   ├── input.rs            # Input dialog (rename symbol, etc.)
│   │   ├── lsp_status.rs       # LSP server status dialog
│   │   # (notification.rs removed — replaced by dioxus-primitives ToastProvider)
│   │   └── prompt.rs           # Command/search prompts
│   ├── picker/                 # Picker components (overlay dialogs)
│   │   ├── mod.rs              # Re-exports GenericPicker
│   │   ├── generic.rs          # Main picker container (two-column with preview)
│   │   ├── item.rs             # PickerItemRow component
│   │   ├── highlight.rs        # HighlightedText for fuzzy matches
│   │   ├── preview.rs          # PickerPreviewPanel: syntax-highlighted file preview
│   │   └── scrollbar.rs        # PickerScrollbar: track+thumb position indicator
│   └── inline_dialog/          # Inline dialog primitives (cursor-positioned)
│       ├── mod.rs              # Re-exports InlineDialogContainer, InlineListDialog
│       ├── container.rs        # Base container with positioning logic
│       └── list.rs             # List dialog with selection support
│
├── keymap/                     # Configurable Keymap System (trie-based)
│   ├── mod.rs                  # DhxKeymapResult, keymap dispatch, key sequence state
│   ├── command.rs              # CommandSlot, AwaitCharKind, command name → EditorCommand mapping
│   ├── default.rs              # Default keymaps for all modes (normal, insert, select, g, Space, etc.)
│   └── trie.rs                 # DhxKeyTrie, DhxKeyTrieNode, TrieSearchResult — trie data structure
│
├── state/                      # State Management
│   ├── mod.rs                  # EditorContext, command dispatch, config loading
│   ├── types.rs                # Data structures (EditorSnapshot, StartupAction, etc.)
│   └── lsp_events.rs           # LspEventOps: poll_lsp_events, diagnostics handling
│
├── operations/                 # Editor Operations (extension traits)
│   ├── mod.rs                  # Re-exports all traits
│   ├── movement.rs             # MovementOps: move_cursor, goto_*
│   ├── editing.rs              # EditingOps: insert_*, delete_*, undo/redo
│   ├── selection.rs            # SelectionOps: extend_*, select_line
│   ├── clipboard.rs            # ClipboardOps: yank, paste, delete_selection
│   ├── macro_ops.rs            # MacroOps: toggle_macro_recording, maybe_record_key, replay_macro
│   ├── search.rs               # SearchOps: execute_search, search_next
│   ├── picker_ops.rs           # PickerOps: show_*_picker, picker_confirm
│   ├── buffer.rs               # BufferOps: switch_to_buffer, save_document
│   ├── cli.rs                  # CliOps: execute_command (88 commands — buffer, clipboard, config, LSP, tree-sitter, etc.)
│   ├── shell.rs                # ShellOps: execute_shell_command (pipe selections)
│   ├── text_manipulation.rs    # TextManipulationOps: sort_selections, reflow_selections
│   ├── theme.rs                # ThemeOps: list_themes, apply_theme, theme_to_css_vars
│   ├── jump.rs                 # JumpOps: jump list navigation (Ctrl-o/i/s)
│   ├── vcs.rs                  # VcsOps: git diff hunks, gutter markers, change navigation
│   ├── lsp.rs                  # LspOps: diagnostic navigation, LSP lifecycle
│   └── word_jump.rs            # WordJumpOps: compute labels, filter, jump
│
└── keybindings/                # Key Handling
    ├── mod.rs                  # Re-exports + shared helpers (direction_from_key, handle_move_keys, etc.)
    ├── translate.rs            # Dioxus KeyboardEvent → helix KeyEvent translation
    ├── completion.rs           # handle_completion_mode, location_picker, code_actions, lsp_dialog
    ├── command.rs              # handle_command_mode
    ├── picker.rs               # handle_picker_mode
    ├── regex.rs                # handle_regex_mode (select/split regex prompt)
    ├── search.rs               # handle_search_mode
    ├── confirmation.rs         # handle_confirmation_mode
    ├── input_dialog.rs         # handle_input_dialog_mode
    └── shell.rs                # handle_shell_mode

helix-dioxus/assets/
├── styles.css                  # Main stylesheet (embedded via include_str!)
└── script.js                   # JavaScript functions (loaded via custom head)
```

### Dioxus 0.7 Patterns

**Hooks Reference:**

- `use_context::<T>()` — read shared state from ancestor provider (`let app_state = use_context::<AppState>();`)
- `use_context_provider(|| ...)` — provide shared state to descendants
- `use_signal(|| initial)` — local mutable state within a component
- `use_effect(move || { ... })` — side effects (DOM manipulation via `document::eval`). **Only re-runs when signal dependencies change** — plain prop values captured in the closure create no dependency. Bridge props to signals with the `use_signal` + `peek`/`set` pattern (see "Prop-to-Signal Bridge" below)
- `use_future(move || async { ... })` — background async tasks (LSP polling, notification drain)
- `use_memo(move || { ... })` — memoized derived values (see Performance section below)

**Component Patterns:**

```rust
// Basic component with props
#[component]
pub fn MyComponent(title: String, count: usize, #[props(default)] optional: bool) -> Element {
    rsx! { div { "{title}: {count}" } }
}

// Component with children
#[component]
pub fn Wrapper(class: String, children: Element) -> Element {
    rsx! { div { class, {children} } }
}

// Component with event handler prop
#[component]
pub fn Button(label: String, on_click: EventHandler<MouseEvent>) -> Element {
    rsx! { div { onmousedown: move |evt| on_click.call(evt), "{label}" } }
}

// Empty return for conditional components
if items.is_empty() {
    return rsx! {};
}
```

**Event Handling:**
- Use `onmousedown` (not `onclick`) for immediate response — `onclick` fires on mouse-up, causing latency
- `evt.stop_propagation()` — prevent event from reaching parent handlers (e.g., backdrop clicks)
- `evt.prevent_default()` — suppress browser defaults (e.g., key events)
- Clone `app_state` for each closure: `let app_state_close = app_state.clone();`

**Conditional Rendering** — use `if` blocks directly inside `rsx!`:

```rust
rsx! {
    if snapshot.picker_visible {
        GenericPicker { /* ... */ }
    }
    if snapshot.hover_visible {
        if let Some(ref html) = snapshot.hover_html {
            HoverPopup { hover_html: html.clone() }
        }
    }
}
```

**Document API:**

```rust
document::Style { {include_str!("../assets/styles.css")} }  // Embed CSS
document::Title { "helix-dioxus - {snapshot.file_name}" }    // Dynamic window title
document::eval("scrollCursorIntoView();");                   // Call JS from Rust
```

### Performance: Memoization and Signal Usage

`EditorSnapshot` has ~50 fields. Every component using `use_snapshot()` re-renders on **any** field change. For components that only need a few fields, use `use_memo` with `use_snapshot_signal()`:

```rust
// BufferBar only needs 2 fields — skip re-renders from cursor/content/mode changes
let signal = use_snapshot_signal();
let buffer_data = use_memo(move || {
    let s = signal.read();
    (s.open_buffers.clone(), s.buffer_scroll_offset)
});
let data = buffer_data.read();
```

**When to use each pattern:**
- `use_snapshot()` — components that use many fields or the full snapshot (e.g., `EditorView`)
- `use_memo` + `use_snapshot_signal()` — components using few fields (e.g., `BufferBar` uses 2, `StatusLine` uses 12)
- `.peek()` — read signal without subscribing (event handlers, side effects)

**Signal Best Practices:**
- `.read()` in component body → subscribes, triggers re-render on change
- `.read()` in event handler → does NOT subscribe (handlers aren't tracked scopes)
- `.peek()` → never subscribes, explicit "read without tracking" intent
- Clone signals freely — they are `Arc`-wrapped and cheap to clone

**Prop-to-Signal Bridge** (for `use_effect` that depends on props):

`use_effect` only tracks *signal* reads — a plain prop value creates no dependency and the effect runs only once. Bridge the prop into a signal:

```rust
let mut scroll_target = use_signal(|| selected);  // init from prop
if *scroll_target.peek() != selected {             // peek: don't subscribe component body
    scroll_target.set(selected);                   // update signal when prop changes
}
use_effect(move || {
    scroll_target.read();                          // read: subscribe the effect
    document::eval("scrollSelectedItem();");
});
```

Used in `GenericPicker` and `InlineListDialog` for scroll-into-view effects.

**Row Keys for `for` Loops:**
- Encode structural flags that change RSX branches (`is_cursor`, `has_sel`, `diff_type`)
- **Never** include monotonically increasing counters (`version`, `render_count`)
- Stable keys let Dioxus diff attributes/children instead of destroying/recreating DOM nodes

**Process-and-Notify Pattern:**

After sending commands, always call `process_and_notify` to update the signal and trigger re-renders:

```rust
// In event handlers (e.g., onmousedown, onkeydown)
app_state.send_command(EditorCommand::SwitchBuffer(doc_id));
app_state.process_and_notify(&mut snapshot_signal);
```

- `process_commands_sync()` — processes commands + updates the mutex snapshot (used by the polling loop)
- `process_and_notify()` — calls `process_commands_sync()` + pushes to the Dioxus `Signal` (used by UI event handlers)
- The LSP polling `use_future` in `app.rs` calls `process_commands_sync()` on a 100ms interval, comparing `snapshot_version` to avoid redundant signal writes

### dioxus-primitives: Toast Notifications

**Dependency:** `dioxus-primitives` (git, `default-features = false`) — only the `ToastProvider` component is used.

**Architecture** (4-part pipeline):

1. **`ToastProvider`** wraps the app in `app.rs` — manages toast lifecycle, auto-dismiss, and max 5 toasts
2. **`NotificationBridge`** (invisible component inside `ToastProvider`) — drains an async `mpsc` channel via `use_future`
3. **`EditorContext`** sends `PendingNotification` via `tokio::sync::mpsc::unbounded_channel` from any operation
4. **Bridge** maps `NotificationSeverity` → `ToastType` and calls `toasts.show()`

**How to send a notification from editor operations:**

```rust
// In any EditorContext method (operations/*.rs, state/mod.rs)
self.show_notification("Renamed to 'new_name'".to_string(), NotificationSeverity::Success);
```

`show_notification` sends a `PendingNotification` through the channel — the bridge picks it up asynchronously.

**Severity mapping and durations:**

| `NotificationSeverity` | `ToastType` | Duration |
|------------------------|-------------|----------|
| `Error` | `ToastType::Error` | 10 seconds |
| `Warning` | `ToastType::Warning` | default (~5s) |
| `Info` | `ToastType::Info` | default |
| `Success` | `ToastType::Success` | default |

**CSS classes** (in `styles.css`): `.toast`, `.toast-container`, `.toast-list`, `.toast-content`, `.toast-title`, `.toast-close`

**Why NOT other dioxus-primitives components:** Only `ToastProvider` is used — other components (context_menu, dialog, tooltip) were evaluated but have build system and interaction model incompatibilities with the desktop WebView.

### Extension Traits Pattern

Operations are organized as extension traits on EditorContext:

```rust
// operations/movement.rs
pub trait MovementOps {
    fn move_cursor(&mut self, doc_id: DocumentId, view_id: ViewId, direction: Direction);
    // ...
}

impl MovementOps for EditorContext {
    fn move_cursor(&mut self, ...) {
        // implementation
    }
}

// In state/mod.rs, import and use:
use crate::operations::{MovementOps, EditingOps, ...};
// Methods automatically available on EditorContext
```

### All dioxus primitives

list with `dx component list`

- accordion: An accordion component for displaying collapsible content sections.
- alert_dialog: An alert dialog component for displaying important messages and requiring user confirmation.
- aspect_ratio: An aspect ratio component for maintaining a consistent width-to-height ratio of an element.
- avatar: An avatar component for displaying user profile images or initials.
- badge: A small label to display status or categorization
- button: A button component for triggering actions or events when clicked.
- calendar: A calendar grid component for selecting dates.
- card: A simple card component
- checkbox: A togglable checkbox component.
- collapsible: A collapsible component for showing and hiding content sections.
- context_menu: A context menu component for displaying a list of actions or option after right clicking an area.
- date_picker: A date picker component to select or input dates.
- dialog: A dialog component for displaying modal content.
- dropdown_menu: A dropdown menu component for selecting options from a list.
- form: A form component for collecting user input.
- hover_card: A hover card component for displaying additional information on hover.
- input: An input field component for user text entry.
- label: An accessible label component for form elements.
- menubar: A menubar component for a collection of menu items.
- navbar: A navbar component for navigation between pages.
- pagination: Navigation controls for paged content.
- popover: A popover component for colapsible content.
- progress: An accessable progress bar indicator.
- radio_group: A group of radio buttons for selecting one option from a set.
- scroll_area: A scrollable area component.
- select: A select dropdown component with typeahead support.
- separator: A visual separator between different sections of the page.
- sheet: A sheet component as an edge panel that complements the main content
- sidebar: A sidebar component as a vertical interface panel fixed to the screen edge, enable quick access to different sections of an application
- skeleton: A placeholder component for all loading elements.
- slider: An accessable slider component.
- switch: A togglable switch component.
- tabs: A tabbed interface component.
- textarea: a textarea component used to allow users to enter multi-line text input
- toast: A toast notification component.
- toggle: A simple toggle button component.
- toggle_group: A group of toggle buttons for selecting one or more options from a set.
- toolbar: A toolbar component for grouping related inputs.
- tooltip: A tooltip component for additional information on hover or focus.

### Assets Pattern

**External Stylesheet**: CSS is embedded via `include_str!` and rendered with `document::Style`:

```rust
// In app.rs
rsx! {
    document::Style { {include_str!("../assets/styles.css")} }
    // ...
}
```

Note: `asset!()` macro requires the `dx` CLI to resolve paths. `include_str!()` works with standard `cargo build`.

**JavaScript Functions**: Custom script is loaded via `include_str!` and wrapped in a script tag:

```rust
// In main.rs
const CUSTOM_SCRIPT: &str = include_str!("../assets/script.js");
// Used with: .with_custom_head(format!("<script>{CUSTOM_SCRIPT}</script>"))
```

Functions defined in `script.js`:
- `focusAppContainer()` - focuses app on mount
- `scrollCursorIntoView()` - scrolls cursor into view
- Global `keydown` listener - re-focuses app container when WebView loses focus after re-renders

**CSS Custom Properties** (`styles.css` uses `:root` variables for theming):
- Colors: `--bg-primary`, `--bg-secondary`, `--bg-highlight`, `--bg-selection`, `--bg-deep`, `--text`, `--text-dim`, `--text-dimmer`, `--accent`, `--error`, `--warning`, `--info`, `--hint`, `--success`, `--purple`, `--orange`
- Kbd: `--kbd-bg`, `--kbd-border`, `--kbd-text`
- Font: `--font-mono`
- Z-index layers: `--z-dropdown` (100), `--z-overlay` (200), `--z-modal` (300), `--z-notification` (300), `--z-confirmation` (400), `--z-tooltip` (9999)

**CSS Classes** (defined in `styles.css`):
- `.modal-overlay`, `.modal-overlay-top`, `.modal-container` (shared overlay/container for all modal dialogs)
- `.app-container`, `.editor-view`, `.gutter`, `.content`
- `.gutter-line`, `.gutter-line-active` (line number row styles)
- `.buffer-bar`, `.buffer-tab`, `.buffer-tabs`, `.buffer-tab-name`, `.scroll-button` (tab bar)
- `.context-menu`, `.context-menu-backdrop`, `.context-menu-item`, `.context-menu-item-disabled`, `.context-menu-separator` (popup context menus)
- `.statusline`, `.statusline-lsp`, `.statusline-recording` (status bar)
- `.picker-*` (container, header, list, list-items, item, body, left, preview)
- `.picker-scrollbar-track`, `.picker-scrollbar-thumb` (picker list scrollbar)
- `.prompt`, `.prompt-cursor`
- `.completion-*`, `.hover-*`, `.code-action-*` (LSP popups)
- `.inline-dialog`, `.inline-dialog-list`, `.inline-dialog-item` (cursor-positioned popups)
- `.toast`, `.toast-container`, `.toast-list`, `.toast-content`, `.toast-title`, `.toast-close` (dioxus-primitives toast notifications)
- `.confirmation-*` (modal confirmation dialogs)
- `.command-completion-*` (command mode autocompletion popup)
- `.input-dialog`, `.input-dialog-*` (rename symbol, etc.)
- `.editor-scrollbar`, `.scrollbar-*` (custom scrollbar with markers)
- `.code-actions-layout`, `.code-actions-list-column`, `.code-actions-preview-column` (two-column preview)
- `.code-action-preview`, `.code-action-diff-*` (diff preview panel)
- `.kbd-key-compact` (compact kbd variant for 20px help bar)
- `.file-type-icon` (Material Icon Theme SVG icons for files/folders)
- `.cursor-secondary-normal`, `.cursor-secondary-select`, `.cursor-secondary-insert` (multi-cursor)
- `.indicator-gutter`, `.indicator-diagnostic`, `.indicator-jumplist` (gutter indicators)
- `.gutter-diff-zone`, `.gutter-diff-bar`, `.gutter-diff-deleted` (VCS diff markers with hover zone)
- `.git-diff-popup`, `.git-diff-popup-header`, `.git-diff-popup-actions`, `.git-diff-popup-btn`, `.git-diff-popup-content` (git diff hover popup)
- `.error-lens` (inline diagnostic messages)
- `.inlay-hint`, `.inlay-hint-type`, `.inlay-hint-param` (LSP inlay hints)
- `.lsp-icon-blinking`, `.lsp-icon-spinning` (LSP status animations)
- `.lsp-dialog-*`, `.lsp-server-*`, `.lsp-restart-btn` (LSP status dialog)
- `.keybinding-help-registers`, `.register-dialog-*` (register viewer)
- `.location-picker-*` (location picker)

**Dynamic Styles**: Styles requiring Rust variables remain inline:
- Mode colors: `style: "background-color: {mode_bg};"`
- Active state: `style: "color: {text_color};"`

### Inline Dialog Pattern

Cursor-positioned popups use the generic inline dialog components:

```rust
// Content dialog (hover, signature help)
use super::inline_dialog::{DialogConstraints, DialogPosition, InlineDialogContainer};

InlineDialogContainer {
    cursor_line,
    cursor_col,
    position: DialogPosition::Above,  // or Below
    class: "my-popup",
    constraints: DialogConstraints { min_width: None, max_width: Some(500), max_height: Some(300) },
    // content as children
}

// List dialog (completion, code actions)
use super::inline_dialog::{InlineListDialog, InlineListItem};

InlineListDialog {
    cursor_line,
    cursor_col,
    selected,
    empty_message: "No items",
    class: "my-list-popup",
    has_items: !items.is_empty(),

    for (idx, item) in items.iter().enumerate() {
        InlineListItem {
            key: "{idx}",
            is_selected: idx == selected,
            // item content
        }
    }
}
```

CSS classes:
- `.inline-dialog` - Base styles for all inline dialogs
- `.inline-dialog-list` - List variant with padding
- `.inline-dialog-item` - Selectable list item
- `.inline-dialog-item-selected` - Selected state
- `.inline-dialog-empty` - Empty state message

### Event System (helix_event)

**CRITICAL**: helix-view and helix-dioxus use helix_event for event dispatching and hook registration. Events MUST be registered before hooks can be registered for them.

**Initialization Order** (in `lib.rs::launch()`):
1. `events::register()` - registers all helix-view event types with helix_event
2. `EditorContext::new()` - creates handlers and registers hooks via `helix_view::handlers::register_hooks()`

**Why This Matters**:
- `helix_view::handlers::register_hooks()` registers hooks for `DocumentDidChange`, `LanguageServerInitialized`, etc.
- These hooks are ESSENTIAL for LSP synchronization:
  - `DocumentDidChange` → sends `textDocument/didChange` to keep LSP in sync with document edits
  - `LanguageServerInitialized` → sends `textDocument/didOpen` for all documents when LSP starts
- Without proper event registration, the app will panic: "Tried to register handler for unknown event"
- Without the hooks, LSP operations like rename will corrupt text because the server has stale content

**Files involved**:
- `events.rs` - registers events with `helix_event::register_event::<T>()`
- `state/mod.rs::create_handlers()` - calls `helix_view::handlers::register_hooks()`
- `state/lsp_events.rs` - dispatches `LanguageServerInitialized` and `LanguageServerExited` events

**When adding new LSP features**: Check if helix-term dispatches any events in its handling code. If so, helix-dioxus must:
1. Register the event type in `events.rs`
2. Dispatch the event at the appropriate time in `lsp_events.rs`

### Keybinding Helpers Pattern

Shared keybinding logic lives in `keybindings/mod.rs`:
- `direction_from_key(code)` → maps hjkl/arrows to `Direction`
- `handle_move_keys(code)` → direction → `MoveLeft/Right/Up/Down`
- `handle_extend_keys(code)` → direction → `ExtendLeft/Right/Up/Down`
- `handle_text_input_keys(code, esc, enter, backspace, char_fn)` → shared Esc/Enter/Backspace/Char pattern (used by search/command/regex modes)
- `handle_list_navigation_keys(code, esc, up, down, enter, backspace?, char_fn?)` → shared list navigation (used by location picker, code actions)

Normal, Insert, and Select modes use trie-based dispatch via the `keymap/` module (configurable via `[keys]` in `config.toml`). Dialog and prompt modes (command, search, picker, regex, completion, confirmation, input, shell) still use dedicated handlers in `keybindings/`.

Multi-key sequences (f/F/t/T, g, Space, [, ], r, m, ") are handled via `PendingKeySequence` enum in `app.rs`.

The `"` prefix selects a register for the next yank/paste/delete:
- `"<char>` → sets `editor.selected_register` (consumed by next clipboard/editing op)
- Examples: `"ay` (yank to `a`), `"ap` (paste from `a`), `"_d` (delete to black hole)

The `m` prefix supports nested sequences:
- `mm` → match bracket
- `mi<char>` → select inside pair
- `ma<char>` → select around pair
- `ms<char>` → surround add
- `md<char>` → surround delete
- `mr<old><new>` → surround replace (3-key sequence)

### Coding Conventions

- Keep components under 300 lines
- Use extension traits for operation grouping
- Prefer match over if-let for mode dispatch
- Always call `process_commands_sync()` after sending commands
- Follow Rust derive order: Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default
- Fields that need cross-module access use `pub(crate)`
- Extract static CSS to `styles.css` with CSS custom properties, keep dynamic styles inline in RSX
- Use CSS custom properties (`var(--name)`) instead of hardcoded color values in CSS

## Build Commands

```bash
# Development build
cargo build -p helix-dioxus

# Run with file (binary is named 'dhx')
cargo run -p helix-dioxus -- <file>

# Run with directory (opens file picker)
cargo run -p helix-dioxus -- <directory>

# Run with glob pattern
cargo run -p helix-dioxus -- "src/*.rs"

# Check compilation (both library and binary)
cargo check -p helix-dioxus --bins --lib

# Lint
cargo clippy -p helix-dioxus --bins --lib

# Tests (use --lib to skip examples)
cargo test -p helix-dioxus --lib

# Run a single test
cargo test -p helix-dioxus --lib test_name

# Documentation
cargo doc -p helix-dioxus --no-deps
```

## Library Usage

helix-dioxus can be used as a library to build custom IDE-like applications:

```rust
use helix_dioxus::{DhxConfig, StartupAction};

fn main() -> anyhow::Result<()> {
    let config = DhxConfig::default()
        .with_window_title("My IDE")
        .with_font_size(16.0);

    helix_loader::initialize_config_file(None);
    helix_loader::initialize_log_file(None);

    let runtime = tokio::runtime::Runtime::new()?;
    let _guard = runtime.enter();

    helix_dioxus::launch(config, StartupAction::None)
}
```

### Configuration

**Two-layer config strategy:**
- **Shared with helix-term**: `~/.config/helix/config.toml` (`[editor]` settings, `theme`) and `languages.toml` (LSP config)
- **GUI-specific**: `~/.config/helix/dhx.toml` for window, font, and logging settings

```toml
# ~/.config/helix/dhx.toml
[window]
title = "My IDE"
width = 1400.0
height = 900.0

[font]
family = "'Fira Code', monospace"
size = 16.0
ligatures = true

[logging]
level = "debug"
log_file = "/tmp/my-ide.log"
```

## Keybinding Comparison

See [KEYBINDINGS.md](KEYBINDINGS.md) for a detailed comparison between helix-dioxus bindings and standard Helix defaults, including matches, deviations, custom extensions, and missing bindings.

## Troubleshooting

### Test file with intentional error (examples/test_error.rs)
- **DO NOT DELETE** this file - it contains an intentional type error for testing LSP diagnostics
- Used to test: error lens, diagnostic underlines, gutter icons, code actions
- When running `cargo test`, use `--bins` flag to skip examples: `cargo test -p helix-dioxus --bins`
- Or exclude examples: `cargo test -p helix-dioxus --lib`

### Selection visibility
- Helix always has a 1-char selection internally (even in Normal mode)
- Solution: Show selection highlighting only when `sel_end > sel_start + 1` (multi-char selections in any mode)

### Component not re-rendering after state change
- Cause: Dioxus 0.7 requires reading a signal to subscribe to its changes
- Solution: Use `use_snapshot()` in the component body to subscribe to `Signal<EditorSnapshot>`
- After sending commands, call `app_state.process_and_notify(&mut signal)` to trigger re-renders

### SelectionDidChange errors in logs
- Cause: WebView events not handled by Dioxus
- Solution: tracing.rs filters these messages

### macOS dock icon not showing
- Cause: Dock icons require .app bundle on macOS
- Status: Known issue, marked as TODO

### LSP rename corrupts text (missing characters after rename)
- Cause: LSP server not receiving `textDocument/didChange` notifications
- Solution: Ensure `events::register()` is called before `EditorContext::new()`, and that `helix_view::handlers::register_hooks()` is called when creating handlers
- See "Event System" section above

### Panic: "Tried to register handler for unknown event"
- Cause: `helix_view::handlers::register_hooks()` called before events are registered
- Solution: Call `events::register()` at the start of `launch()` before creating `EditorContext`

### WebView loses focus after re-renders (keys stop working)
- Cause: Dioxus desktop WebView can lose focus on the app container div after re-renders, causing `onkeydown` to stop firing
- Solution: Global `document.addEventListener('keydown', ...)` in `script.js` re-focuses the app container whenever focus is lost
- This is essential — without it, keyboard input intermittently stops working

### Scrollbar track click and thumb drag not working
- Cause: Both interactions require the scrollbar track's pixel height to convert mouse Y coordinates into a document-line ratio. All approaches to obtain element height in the Dioxus desktop WebView (getBoundingClientRect, onmounted, ResizeObserver) return 0
- Status: **BLOCKED** — see [SCROLLBAR_FIX_INVESTIGATION.md](SCROLLBAR_FIX_INVESTIGATION.md) for detailed investigation and unexplored approaches
- Marker click-to-navigate and tooltips work correctly (they use known line numbers, not pixel ratios)

### Alt+key bindings not working on macOS
- Cause: macOS Option key composes special characters (Alt+o → ø, Alt+i → ˆ, Alt+c → ç). `evt.key()` returns the composed character, so `KeyCode::Char('o')` with ALT modifier never matches
- Solution: In `translate_key_code`, when Alt is pressed, use `evt.code()` (physical key) via `key_code_from_physical()` to get the intended character instead of the composed one
- Affected bindings: Alt+o/i (expand/shrink), Alt+. (repeat), Alt+; (flip selections), Alt+d (delete no yank), Alt+c/C (copy selection), Alt+s (split), Alt+x (shrink to line bounds), Alt+` (case)

## Emoji Picker

- **Trigger**: `Ctrl+Cmd+Space` in insert mode, or `:emoji` command
- **Crate**: `emojis` v0.8 (Unicode 17.0, all standard emojis with names and shortcodes)
- **UI**: Reuses `GenericPicker` with `PickerMode::Emojis`, `PickerIcon::Emoji` (Smile icon)
- **Insertion**: `EditorCommand::InsertText(String)` — supports multi-codepoint emojis (flags, ZWJ sequences)
- **Meta modifier**: `translate_modifiers()` maps `mods.meta()` → `KeyModifiers::SUPER`

## Design Decisions

- **Window/Splits**: Not supported — helix-dioxus uses a single-view design. `C-w` prefix and `Space w` sub-menu will not be implemented.
- **DAP/Debug**: Not supported — `Space G` sub-menu will not be implemented. Debug adapter protocol is not integrated.

## Development History

See [DEV_LOGBOOK.md](DEV_LOGBOOK.md) for detailed development history and completed features.

## Long-term Roadmap

Design notes and long-term vision (IDE layout, perspectives, views, plugins, automation) are maintained in `~/Documents/Workspaces/_ideas/DNA - Dioxus + Helix/`.
